
[{"content":"","date":"2025-02-11","externalUrl":null,"permalink":"/","section":"Itsuka的小站","summary":"","title":"Itsuka的小站","type":"page"},{"content":"","date":"2025-02-11","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025-02-11","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-02-11","externalUrl":null,"permalink":"/tags/%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/","section":"Tags","summary":"","title":"阶段总结","type":"tags"},{"content":"我个人比较偏向于把数论和组合的卷积和反演分开理解.\n实际上是组合数太难了（逃……\n常见名词 #\r单位元 \\(\\varepsilon(n)\\) #\r$$\\varepsilon(n)=[n=1]$$\n显然完全积性.\n逆元 \\(f^{-1}\\) #\r当 \\(f*f^{-1}=\\varepsilon\\) 时，称 \\(f^{-1}\\) 是 \\(f\\) 的逆.\n幂函数 \\(ID_k(n)\\) #\r\\(ID_k(n)=n^k\\) ，特别地，\r\\(ID(n)=n\\) .\n显然完全积性.\n除数函数 \\(\\sigma_k(n)\\) #\r$$\\sigma_k(n)=\\sum_{d|n}d^k$$\n感性理解 \\(\\sigma_k(n)\\) 表示 \\(n\\) 的所有因子 \\(k\\) 次幂之和.\n显然积性.\n比如，\r\\(\\sigma_0(n)\\) 表示 \\(n\\) 的因数个数，\r\\(\\sigma_1(n)\\) 表示 \\(n\\) 的因数和.\n欧拉函数 \\(\\varphi(n)\\) #\r$$\\varphi(n)=\\sum_{i=1}^{n}[(i,n)=1]$$\n说人话就是在 \\(1\\sim n\\) 中和 \\(n\\) 互质的数的个数.\n四个式子：\n这是个积性函数，即当 \\((i,j)=1\\) 时，\r\\(\\varphi(ij)=\\varphi(i)\\times\\varphi(j)\\) .\n这里有欧拉反演的一个看起来比较正常的形式：\r\\(n=\\sum_{d|n}\\varphi(d)\\) .\n求单个欧拉函数：\r\\(\\varphi(n)=n\\times\\prod_{i=1}^k\\frac{p_i-1}{p_i}\\) ，此处 \\(n=\\prod_{i=1}^kp_i^{c_i}\\) .\n若 \\(n=p^k\\) ，则 \\(\\varphi(n)=p^k-p^{k-1}\\) .\n莫比乌斯函数 \\(\\mu(n)\\) #\r$$\\mu(n)=\\begin{cases}1\u0026amp;\u0026amp; n=1\\\\ 0 \u0026amp;\u0026amp; n\\ 含有平方因子 \\\\ (-1)^k \u0026amp;\u0026amp; k\\ 为\\ n\\ 的本质不同质因子个数\\end{cases}$$\n三个式子：\n这也是个积性函数，即当 \\((i,j)=1\\) 时，\r\\(\\mu(ij)=\\mu(i)\\times\\mu(j)\\) .\n\\(\\sum_{d|n}\\mu(d)=[n=1]=\\varepsilon(n)\\) ，这个会拿去做反演和卷积.\n据说有拓展形式，日后再补.\n常见卷积 #\r狄利克雷（Dirichlet）卷积 #\r$$(f*g)(n)=\\sum_{d|n}f(d)\\times g(\\frac{n}{d})$$\n这个定义式在有些题目中可以化为卷积形式，然后用莫比乌斯反演推式子求解.\n几个性质：\n若 \\(f\\)、\r\\(g\\) 都是积性函数，则 \\(f\\ast g\\) 也是积性函数.\n交换律：\r\\(f\\ast g=g\\ast f\\)\n结合律：\r\\(f\\ast (g\\ast h)=(f\\ast g)\\ast h\\)\n分配律：\r\\((f+g)\\ast h=f\\ast h+g\\ast h\\)\n基本上可以把这个卷积视作定义在函数之间的新运算，除此之外，一般题目的式子大概率是不会把定义式化过来化过去的.\n一些卷积式 #\r\\(\\varepsilon=\\mu*1\\) ，直接按定义式展开易证，不难发现 \\(\\mathrm{RHS}=\\sum_{d|n}\\mu(d)=[n=1]=\\varepsilon(n)\\) 也就是莫比乌斯函数的性质2.\n由上式，可以知道 \\(\\mu=1^{-1}\\) ，所以有 \\(g=f*\\pmb 1 \\Leftrightarrow f=g*\\mu\\) ，即\n$$g(n)=\\sum_{d|n}f(d)\\Leftrightarrow f(n)=\\sum_{d|n}\\mu(d)g(\\frac{n}{d})$$\n这就是常见的莫比乌斯反演的形式. 更进一步的，还有\n$$\\sum_{d|(i,j)}\\mu(d)=\\varepsilon\\left((i,j)\\right)$$\n\\(\\sigma_0=1*1\\)\n\\(\\sigma_1=ID*1\\)\n\\(\\sigma_2=ID*ID\\)\n\\(ID=\\varphi*1\\) ，这就是欧拉反演的卷积式形式.\n\\(\\varphi=\\mu*ID\\)\n\\((ID_n\\cdot \\mu)*ID_n=\\varepsilon\\)\n\\((ID_n\\cdot \\varphi)*ID_n=ID_n\\)\n常见定理 #\r欧拉定理 #\r若 \\(n\\)、\r\\(a\\) 互素，则 \\(a^{\\varphi(n)}\\equiv 1 \\pmod n\\) .\n拓展欧拉定理 #\r$$a^b\\equiv \\begin{cases}a^{b\\bmod \\varphi(p)}\u0026amp;(a,p)=1\\\\a^b\u0026amp;(a,p)\\ne 1,b\u0026lt;\\varphi(p)\\\\a^{b\\bmod \\varphi(p)+\\varphi(p)}\u0026amp;(a,p)\\ne 1,b\\geq\\varphi(p)\\\\\\end{cases} \\mod m$$\n常用于解决“幂的幂次”以及“幂的递归”一类问题.\n在有些数论题目中会客串，要注意模数的不同.\n筛子 #\r线性筛 #\r可以线性递推积性函数的值，最常见的比如 \\(\\varphi(i)\\) 和 \\(\\mu(i)\\) .\n埃氏筛 #\r很少用. 可以分块递推大质数表，但这好像是另外一个算法了.\n详见Wheel Factorization 模板 - SP6488.\n杜教筛 #\r可以在亚线性复杂度内求积性函数前缀和.\n除此之外，还需要惊人的注意力\n引理：对于任意数论函数 \\(f\\)、\r\\(g\\) 满足 \\(S_{f*g}(n)=\\sum_{i=1}^{n}g(i)\\cdot S_f([\\frac{n}{i}])=g(1)S_f(n)+\\sum_{i=2}^{n}g(i)S_f([\\frac{n}{i}])\\)\n总的来说，有了这个引理，我要是想求 \\(f\\) 函数前缀和，就只需要构造一个函数 \\(g\\) 使得 \\(f*g\\) 是易求的，再套上下面的式子递归处理就ok了.\n$$\\boxed{S_f(n)=\\frac{1}{g(1)}\\left(S_{f*g}(n)-\\sum_{i=2}^{n}g(i)\\cdot S_f([\\frac{n}{i}])\\right)}$$\n那么，举个例子，假如我要求 \\(\\varphi\\) 的前缀和，因为我知道 \\(\\varphi*1=ID\\) ，所以有：\n$$S_\\varphi(n)=S_{f*g}(n)-\\sum_{i=2}^{n}S_\\varphi([\\frac{n}{i}])\\\\S_\\varphi(n)=\\frac{n(n+1)}{2}-\\sum_{i=2}^{n}S_\\varphi([\\frac{n}{i}])$$\n然后把这个写到记忆化搜索里面去就ok了.\n再举个例子，假如要求 \\(\\mu\\) 的前缀和，同理，由 \\(\\mu*1=\\varepsilon\\) 可得 \\(S_\\mu(n)=1-\\sum_{i=2}^{n}S_\\mu([\\frac{n}{i}])\\) （注意 \\(S_\\varepsilon(n)=1\\) ）.\n代码实现参见【模板】杜教筛.\n对于不常见函数的杜教筛，后面再补充.\n总的来说，一般的题目只需要记好之前提到的常见卷积式就ok啦.\nPN筛 #\r定义（Powerful Number）：任意素因子次数均大于等于 \\(2\\) 的数.\n引理：所有PN都可以写成 \\(a^2b^3\\) 的形式.\nPN筛：对于积性函数 \\(f\\) ，构造积性函数 \\(g\\) ，使积性函数 \\(h=f\\ast g^{-1}\\) 仅在PN处有值，从而 \\(S_f=S_g\\ast h\\) .\n算法（暴力搜索PN表）：直接暴力搜素数次数，时间复杂度 \\(O(\\sqrt{n})\\) .\n定义（素数拟合）：对于函数 \\(f\\)、\r\\(g\\) ，\r\\(\\forall p\\in P\\) ，\r\\(f(p)=g(p)\\) .\n引理：若积性函数 \\(f\\)、\r\\(g\\) 素数拟合且 \\(f(1)=g(1)=1\\) ，则 \\(h=f*g^{-1}\\) 仅在PN处有值（PN函数）.\n引理：若 \\(h\\) 为PN函数，代入 \\(f=g*h\\) 可得：\n$$\\boxed{S_f(n)=\\sum_{d\\in[1,n]\\ \\mathrm{and}\\ d\\ \\mathrm{is}\\ PN}h(d)S_g([\\frac{n}{d}])}$$\n那么整个求解过程可以分成三个板块：\n递归或预处理Powerful Number \\(d\\) .\n求解积性函数 \\(h\\) 在某个点上的值.\n求解 \\(S_g\\) ，也就是积性函数 \\(g\\) 的前缀和.\n对于 3 ，一般使用杜教筛求解.\n对于 2 ，由于 \\(h\\) 是积性函数，所以只需要求 \\(h(p^c)\\) 后递推即可，那么此时有三种方法可以选择：\n通项公式（前提是超级强大的数学功底）.\n逆元：通过 \\(g\\ast g^{-1}=\\varepsilon\\) 求逆后，用 \\(h=f_k\\ast g^{-1}\\) 求解.\n通用解法：\n由 \\(f=g*h\\) ，有 \\(f(p^c)=g(1)h(p^c)+\\sum_{i=1}^cg(p^i)h(p^{c-i})\\)\n移项：\r\\(h(p^c)=f(p^c)-\\sum_{i=1}^cg(p^i)h(p^{c-i})\\)\n接下来枚举 \\(p\\) 递推 \\(c\\) 即可.\n对于 1 ，小小DFS即可将其拿下.\n代码实现参见【模板】Min_25筛.\n","date":"2025-02-11","externalUrl":null,"permalink":"/posts/number-theory/","section":"Posts","summary":"","title":"数论总结","type":"posts"},{"content":"","date":"2025-02-11","externalUrl":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6/","section":"Tags","summary":"","title":"数学","type":"tags"},{"content":"update: 2023/12/12 fixed pictures\nupdate: 2025/02/12 fixed KaTeX\n本文中所有图片均使用Power Point制作\n基本分块 #\r俗话说得好：\n\\(\\Huge 暴力+暴力=分块\\)\n分块总的来说就是线段树的阉割版，其时间复杂度基本维持在 \\(\\sqrt N\\) 数量级。一般的分块支持单点/区间查询以及单点/区间修改.\n分块的块长一般是 \\(\\sqrt N\\) （ \\(N\\) 是数组大小），例如，对于一个数组 \\(A\\) ，\r\\(|A|=13\\) ，每一块的长度便是 \\(\\sqrt {13}\\approx3\\) ，但是分块完成后我们会发现最后一块的大小是 \\(1\\) ，不足其他块的大小（如下图）.\n区间修改区间查询 #\r分了块后我们便可以干很多事了，单点查询/修改就不说了，直接访问数组下标进行修改.我们来说说区间查询/修改，例如还是那个数组 \\(A\\) ，现在我们要修改下标为 \\(2\\) 到 \\(7\\) 的区间，这个时候我们要对每一块生成一个懒标记，于是我们的思路便很明确了，对于这段区间里整块的部分直接修改懒标记，剩下的不足一整块暴力修改（如下图）.同理，查询也是一样，只是要注意统计时要把所有懒标记加上，不管是整块还是不足整块.下面也会给出一份区间修改（增加）区间查询（最大值）的代码.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int inf = 0x3fffffff; int n, m, s; int a[100100], chunk[100100], lazy[100100]; void modify(int x, int y, int z) { int i = (x-1)/s+1; int j = (y-1)/s+1; chunk[i] = -inf; chunk[j] = -inf; if (i == j) { for (int k = x; k \u0026lt;= y; k++) { a[k] += z; } for (int k = (i-1)*s+1; k \u0026lt;= j*s; k++) { if (a[k] \u0026gt; chunk[i]) chunk[i] = a[k]; } } else { for (int k = x; k \u0026lt;= i*s; k++) { a[k] += z; } for (int k = (i-1)*s+1; k \u0026lt;= i*s; k++) { if (a[k] \u0026gt; chunk[i]) chunk[i] = a[k]; } for (int k = (j-1)*s+1; k \u0026lt;= y; k++) { a[k] += z; } for (int k = (j-1)*s+1; k \u0026lt;= j*s; k++) { if (a[k] \u0026gt; chunk[j]) chunk[j] = a[k]; } for (int k = i+1; k \u0026lt; j; k++) { lazy[k] += z; } } } int search(int x, int y) { int i = (x-1)/s+1; int j = (y-1)/s+1; int ans = -inf; if (i == j) { for (int k = x; k \u0026lt;= y; k++) { if (a[k]+lazy[i] \u0026gt; ans) ans = a[k]+lazy[j]; } } else { for (int k = x; k \u0026lt;= i*s; k++) { if (a[k]+lazy[i] \u0026gt; ans) ans = a[k]+lazy[i]; } for (int k = (j-1)*s+1; k \u0026lt;= y; k++) { if (a[k]+lazy[j] \u0026gt; ans) ans = a[k]+lazy[j]; } for (int k = i+1; k \u0026lt; j; k++) { if (chunk[k]+lazy[k] \u0026gt; ans) ans = chunk[k]+lazy[k]; } } return ans; } signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); s = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, a+i); if (i%s == 1 || a[i] \u0026gt; chunk[(i-1)/s+1]) chunk[(i-1)/s+1] = a[i]; } cin \u0026gt;\u0026gt; m; while (m--) { char op[3]; int x, y, z; scanf(\u0026#34;%s%d%d\u0026#34;, op, \u0026amp;x, \u0026amp;y); if (op[2] == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; z; modify(x, y, z); } else { cout \u0026lt;\u0026lt; search(x, y) \u0026lt;\u0026lt; endl; } } } /* Input: 5 1 2 3 2 5 5 ADD 1 4 3 ASK 2 3 ASK 3 5 ADD 2 4 2 ASK 2 5 Output: 6 6 8 */ 动态区间第 \\(K\\) 小 #\r分块的大部分题目并不像这样简单，例如下面的动态区间第 \\(K\\) 小数例题.\n给定一个由 \\(N\\) 个数组成的序列 \\({A_1,A_2,\u0026hellip;,A_N}\\) 每次可以将 \\(A_k\\) 的值改为 \\(t\\) ，或者提问序列中 \\({A_l,..,A_r}\\) 中第 \\(k\\) 小的数的值.\n对于这道题，我们需要使用另一个数组 \\(B\\) 用来将每个块内的元素排序，需要查询时先使用二分答案，再在 check() 内对于整块的统计答案直接使用排序的数组进行二分，正所谓一个分块套二分再套二分，细节很多，详见下码.\nvoid modify(int k, int t) { // 单点修改，需要排序 int F = (k-1)/s+1; a[k] = t; b[F].clear(); for (int i = (F-1)*s+1; i \u0026lt;= F*s; i++) { b[F].push_back(a[i]); } sort(b[F].begin(), b[F].end()); } int check(int x, int y, int f) { // 统计信息 int i = (x-1)/s+1; int j = (y-1)/s+1; int ans = 0; if (i == j) { for (int k = x; k \u0026lt;= y; k++) { if (a[k] \u0026lt; f) ans++; } } else { for (int k = x; k \u0026lt;= i*s; k++) { if (a[k] \u0026lt; f) ans++; } for (int k = (j-1)*s+1; k \u0026lt;= y; k++) { if (a[k] \u0026lt; f) ans++; } for (int k = i+1; k \u0026lt; j; k++) { ans += lower_bound(b[k].begin(), b[k].end(), f) -b[k].begin(); // 直接二分统计整块内的答案 } } return ans; } int query(int x, int y, int k) { // 二分答案 int l = 0, r = 50005, mid; while (l+1 \u0026lt; r) { mid = (l+r)\u0026gt;\u0026gt;1; if (check(x, y, mid) \u0026gt;= k) r = mid; else l = mid; } return l; } 带多个懒标记的分块 #\r除此之外，还有要同时开两个 lazy 的题目——数列分块入门7，关键在于处理两个运算法则之间的优先级.\n数列分块入门5——在根号开到一定程度时块内的元素会全部变为 \\(1\\)，这时可以不用暴力统计，直接计算块长.\n块状链表 #\r另外，还有一类分块题，算是属于半个块状数组（或者说块状链表）.\n众所周知，数组访问时间复杂度 \\(O(1)\\) ，修改 \\(O(n)\\) ，而链表访问 \\(O(n)\\) ，修改 \\(O(1)\\) .\n而块状链表，就是两者的结合体，它查询 \\(O(\\sqrt n)\\) ，修改 \\(O(\\sqrt n)\\) ，两者时间复杂度相差不大，是个折中方案，具体长什么样见下图.\n那我们应该如何维护来保证它们的时间复杂度呢？很简单，我们只需要在一个块的大小大于一定的值后暴力拆分成两块接在原块后面，具体来说，我们要在一块的大小大于 \\(2\\sqrt N\\) 时分裂（注意：此处的 \\(N\\) 指的是所有元素，包括了后面新增的元素，也就是说每次添加元素时要重新计算阈值长度）.理清思路后，代码实现很简单了（见下，例题）.\nint cnt; // 总块数，用于给新块编号 int nc; // 元素总数 typedef pair\u0026lt;int, int\u0026gt; pii; // 不会吧不会吧，都3202年了不会还有人不会用typedef吧 pii locate(int x) { // 定位元素 int i = 1; while (x \u0026gt; block[i].siz) { x -= block[i].siz; i = block[i].to; } return {i, x}; } void split(int x, int y) { cnt++; for (int i = y; i \u0026lt;= block[x].siz; i++) { block[cnt].a[++block[cnt].siz] = block[x].a[i]; block[x].a[i] = 0; } block[cnt].to = block[x].to; block[x].to = cnt; } // 临时定义一下（不要问我为什么不开变量 #define x p.first #define y p.second void insert(int t, int v) { pii p = locate(t); // 暴力插入 for (int i = block[x].siz; i \u0026gt;= y; i--) { block[x].a[i+1] = block[x].a[i]; } block[x].siz++; block[x].a[y] = v; nc++; s = sqrt(nc); if (block[x].siz \u0026gt;= 2*s) { split(x, block[x].siz/2+1); block[x].siz = block[x].siz/2; } } #undef x #undef y int query(int x) { // 极简的查询的函数 pii p = locate(x); return block[p.first].a[p.second]; } 莫队 #\r除了一般的分块题和块状链表外，分块还有一个重要作用——莫队，它可以解决一部分的区间查询题目(尤其是查询某种区间有几种值的).\n先说本质，本质并不是分块，而是双指针.莫队在运行时会用到两个数组，一个是原来的数组，另一个是 cnt 数组，cnt 数组是用来记录每个数出现的次数(在某些时候可能需要配合离散化食用).下面是算法基本的运行过程.\n首先我们有两个指针 i 和 j ，先不考虑为什么他们在这个位置上，现在我们要把他们移到既定位置.我们有一种很简单的思路，先把左（ i ）移到既定位置的左端点，再把右（ j ）移到既定位置的右端点上.而在这个期间，我们可以顺便统计 cnt 数组，并且维护 tot 变量（统计种类，具体来讲是在 cnt 某个值从 \\(0\\) 到 \\(1\\) 或是从 \\(1\\) 到 \\(0\\) 的过程中修正）.于是我们就有了一个基本的模型了，就是不断通过移动双指针来处理每个询问，但是很明显，这样移来移去，i 最多会移动 \\(MN\\) 次（ \\(M\\) 是询问次数，\r\\(N\\) 是数组长度），j 也同理，这样的时间复杂度是不行的.而莫队算法就是在此处做了优化.\n不带修版本 #\r莫队首先会把询问离线，并把数组的点进行分块，而排序询问的第一关键字是每个询问左端点所在块的编号，而第二关键字是右端点.具体实现如下：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m, s; int a[50050], cnt[1000010]; int ans[200020], tot = 0; // ans是将答案还原的数组 struct node { int l, r, id; } q[200020]; bool cmp(node a, node b) { if ((a.l-1)/s+1 == (b.l-1)/s+1) return a.r \u0026lt; b.r; // 排序 return a.l \u0026lt; b.l; } void add(int p) { if (++cnt[a[p]] == 1) tot++; // 对应左端点左移与右端点右移 } void del(int p) { if (--cnt[a[p]] == 0) tot--; // 对应左端点右移与右端点左移 } signed main() { cin \u0026gt;\u0026gt; n; s = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } cin \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].id = i; } sort(q+1, q+m+1, cmp); // 处理询问 int l = 0, r = 0; for (int i = 1; i \u0026lt;= m; i++) { while (r \u0026lt; q[i].r) add(++r); while (r \u0026gt; q[i].r) del(r--); while (l \u0026lt; q[i].l) del(l++); while (l \u0026gt; q[i].l) add(--l); ans[q[i].id] = tot; } for (int i = 1; i \u0026lt;= m; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; endl; } return 0; } 带修版本 #\r除此之外，莫队还有一种带修改版本.\n不是说了将询问离线了吗，离线处理时怎么修改啊.\n还是可以修改的，现在带修改功能得将修改的点还原到询问前的状态.\n现在时间也得移来移去了.\n嗯？时间移来移去？像 i 和 j 那样？\n那这就好实现了啊.新增一维来处理时间.\n具体怎么讲？\n记录一下每次修改前后的状态，每次将时间移动时便一步步更换状态，直到回溯到指定时间，同时 cmp 函数也要改一下.\n于是，我们就有了这个代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; // 回避关键词检测的打包函数 #define pack1 {x, y, ccnt, qcnt} #define pack2 {x, y} using namespace std; int l, r; int n, m, s, tcnt; int a[133344], cnt[1000010]; int ans[133344], tot; int chunk[133344]; struct node{ // 记录询问 int l, r, t, i; }q[133344]; int qcnt; bool cmp(node a, node b) { // 新的排序函数 if (chunk[a.l] == chunk[b.l] \u0026amp;\u0026amp; chunk[a.r] == chunk[b.r]) return a.t \u0026lt; b.t; if (chunk[a.l] == chunk[b.l]) return a.r \u0026lt; b.r; return a.l \u0026lt; b.l; } struct cg{ // 记录修改 int i, v; }c[133344]; int ccnt; void add(int p) { tot += !cnt[p]++; // 用于l与r的修改，意义同上 } void del(int p) { tot -= !--cnt[p]; // 同上 } void timem(int i, int p) { if (q[i].l \u0026lt;= c[p].i \u0026amp;\u0026amp; c[p].i \u0026lt;= q[i].r) { // 时间更改器（雾 del(a[c[p].i]); add(c[p].v); } swap(a[c[p].i], c[p].v); // 因为有去必有回，所以下一次使用这个位置一定是把它更改回来 } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; s = pow(n*1.0, 2.0/3.0); // 适用于莫队的特殊分块大小 for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; chunk[i] = (i-1)/s+1; // 记录块号（也可以不记） } for (int i = 1; i \u0026lt;= m; i++) { char op; int x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == \u0026#39;Q\u0026#39;) { q[++qcnt] = pack1; } else { c[++ccnt] = pack2; } } sort(q+1, q+qcnt+1, cmp); int l, r, t; l = r = t = 0; for (int i = 1; i \u0026lt;= qcnt; i++) { // 将三个维度移至指定位置 while (l \u0026lt; q[i].l) del(a[l++]); while (l \u0026gt; q[i].l) add(a[--l]); while (r \u0026lt; q[i].r) add(a[++r]); while (r \u0026gt; q[i].r) del(a[r--]); while (t \u0026lt; q[i].t) timem(i, ++t); while (t \u0026gt; q[i].t) timem(i, t--); ans[q[i].i] = tot; // 记录答案 } for (int i = 1; i \u0026lt;= qcnt; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; endl; } return 0; } ","date":"2023-07-17","externalUrl":null,"permalink":"/posts/sqrt-decomposition/","section":"Posts","summary":"","title":"分块思想","type":"posts"},{"content":"","date":"2023-07-17","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"数据结构","type":"tags"},{"content":"","date":"2023-07-17","externalUrl":null,"permalink":"/tags/%E6%80%9D%E6%83%B3/","section":"Tags","summary":"","title":"思想","type":"tags"},{"content":"update: 2023/12/12 fixed pictures\nupdate: 2025/02/12 fixed KaTeX\n内容大纲 #\r|- 二分图\r| |- 二分图的判定\r| | |- 染色法\r| | |- 不存在奇环（长为奇数的环）\r| |- 二分图最大匹配（匈牙利算法）\r| |- 二分图最小点覆盖（König定理二分：二分图中，最小点覆盖=最大匹配）\r| |- 二分图最大独立集（二分图中，最大独立集=n-最小点覆盖）\r| |- 例题（关于建边）\r|- 图的联通\r| |- 定义（只有概念，详细定义见下）\r| | |- 无向图中的定义\r| | | |- 连通图\r| | | |- 子图\r| | | |- 连通子图\r| | | |- 连通分量（最大联通子图）\r| | |- 有向图中的定义\r| | | |- 强连通图\r| | | |- 强连通子图\r| | | |- 强连通分量\r| | | |- k连通图（双连通图）\r| | | |- 割点\r| | | |- 桥\r| | | |- 双连通分量\r| | | |- 点双连通分量\r| | | |- 边双连通分量\r| |- 算法\r| | |- 如何求强连通分量（SCC）= 如何缩点\r| | | |- Kosaraju算法\r| | | |- Tarjan算法\r| | | |- Gabow算法（略）\r| | |- 如何求桥/割点\r| | | |- Tarjan算法（对还是它）\r| | |- 如何求点/边双连通分量\r| | | |- Tarjan算法（啊？） 学习内容——各种定义 #\r强连通/连通图 #\r在无向图中，任意两点都直接或间接连通，则称该图为 连通图(connected).\n相应的，有向图中任意一点都存在路径到达任意另一点，则称该有向图为 强连通图(strong connected) .\n子图 #\r在一个图 \\(H\\) 中，\r\\(H\\) 的所有边属于图 \\(G\\) 的所有边，\r\\(H\\) 的所有点属于图 \\(G\\) 的所有点，则称图 \\(H\\) 是图 \\(G\\) 的 子图(subgraph) .\n连通分量 #\r无向图 \\(G\\) 的最大连通子图称为 \\(G\\) 的 连通分量(connected components) .\n何为最大连通子图？这个子图是 \\(G\\) 的连通子图，将 \\(G\\) 的任何一个不在这张子图中的点加入这张子图后，该子图不再连通.\n强连通分量（SCC） #\r在任意有向图中能够实现强连通的部分我们称其为 强连通分量(Strongly connected component)，如下图，蓝色框内的分别是一个强连通分量.\n如果把每个强连通分量收缩为单个顶点，得到的是一个 有向无环图(DAG)，于是我们可以在这个图的基础上进行拓扑排序，详见此例题.\n而求这个强连通分量，我们可以使用两个算法：Kosaraju算法，Tarjan算法.\nKosaraju算法的流程如下：\n重复寻找图 \\(G\\) 中未被讨论的点，从它开始DFS后序遍历图 \\(G\\) ，遍历到的点置为已讨论，用数组记录每个点到达的先后次序，直到找不到没有讨论的点. 将图 \\(G\\) 反向得到图 \\(G^\\prime\\) ，重置所有点为未讨论. 一直从数组中未讨论的最后一个点出发，DFS后续遍历图 \\(G^\\prime\\) ，DFS每完成一次，就说明找到了一个强连通分量，直到数组中没有未讨论的点. 这是Kosaraju算法的模板（之所以Kosaraju算法没有放在SCC的模板内，是因为这个算法相对于Tarjan算法少用很多）：\nbool g[1001][1001]; // 这里使用的是邻接矩阵 bool vis[1001]; int lis[1001], cnt = 0; int tag[1001], scc = 0; bool ind[1001]; void dfs1(int u) { vis[u] = 1; for (int i = 1; i \u0026lt;= n; i++) { if (g[u][i] \u0026amp;\u0026amp; !vis[i]) dfs1(i); } lis[++cnt] = u; } void dfs2(int u) { vis[u] = 1; tag[u] = scc; for (int i = 1; i \u0026lt;= n; i++) { if (g[i][u] \u0026amp;\u0026amp; !vis[i]) dfs2(i); // 这里注意，判断的边是g[i][u]，因为我们要在反图上跑dfs2() } } int main() { for (int i = 1; i \u0026lt;= n; i++) vis[i] = 0; // 这里可以用memset for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) dfs1(i); } for (int i = 1; i \u0026lt;= n; i++) vis[i] = 0; for (int i = cnt; i \u0026gt;= 1; i--) { if (!vis[lis[i]]) { scc++; dfs2(lis[i]); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if ((tag[i] != tag[j]) \u0026amp;\u0026amp; g[i][j]) { // 此处为缩点 } } } } 接下来我们来说说Tarjan算法，这个算法相对于上个算法理解起来要困难些.\n在Tarjan算法中，最为重要的两个数组是 dfn[] 和 low[] ， dfn[i] 记录的是编号为i的节点在DFS的整个过程的顺序，它会在第一次访问到 \\(i\\) 节点时更改，此后将不会变化；low[i] 表示的是 i 与其之后遍历到的节点所能到达的节点中 dfn 最小的 dfn ，在初始化时 dfn[i]=low[i] .\nTarjan算法在运行时会生成一棵搜索树，但是我们知道，图!=树，因为图中有一些边会使得“树”有环，自然，在生成树后，有一些边会直接指向已遍历的节点，没遍历的节点会在下一步当作自己的孩子进行遍历，而指向已遍历节点的边就是导致“树”有环的罪魁祸首.按照定义，当发现有这种边的存在时，需要更新当前节点的 low[] 值，需要更新为 min(dfn[这些边指向的节点]) .而理所当然地，我们也要被孩子节点更新 low 值为 min(low[孩子节点]) .\n现在我们聚焦某一个点 \\(i\\)，观察 dfn[i] 与 low[i] 的关系，以下是两种情况：\ndfn[i]\u0026gt;low[i] ，这说明 \\(i\\) 或其子孙节点存在边连到 \\(i\\) 上方的节点. dfn[i]=low[i] ，这说明 \\(i\\) 以及其子孙节点无法连到 \\(i\\) 上方的节点，那么这个点 \\(i\\) 就是一个强连通分量在这颗搜索树的根. 但是，\r\\(i\\) 的子孙节点有可能会组成另一个强连通分量，这意味着 \\(i\\) 的子树的节点不一定和 \\(i\\) 处在同一个强连通分量内，我们需要 栈 来解决这个问题.\n现在，我们用一张图看一下 dfn[] 与 low[] 的关系。\n在这张图中，有 (3,4,5,6) ，7 ，8 ，1 ，2 这四个强连通块.\n下图是Tarjan算法的运行过程.\n因为SCC模板就是Tarjan算法，所以在这里不放代码.\n二分图的最大匹配 #\r何为二分图？二分图是一种特殊的无向图，它的顶点可以被分为两个互斥的独立集 \\(U\\) 和 \\(V\\) 的图，使得所有边都是连结一个 \\(U\\) 中的点和一个 \\(V\\) 中的点（如下图所示）.\n何为匹配？一个图的匹配是这个图中一些边所形成的集合，满足任意集合中的两条边都没有公共顶点.\n解决这个问题的算法之一是匈牙利算法.在了解这个算法之前，我们先要了解一下何为增广路（增广轨/交错轨）.\n增广路：若 \\(P\\) 是图 \\(G\\) 中一条连通两个未匹配顶点的路径，并且已匹配和未匹配的边（也就是属匹配边集 \\(M\\) 的边和不属 \\(M\\) 的边）在 \\(P\\) 上交替出现，则称 \\(P\\) 为相对于 \\(M\\) 的一条增广路径.\n不难发现，如果我们把 \\(P\\) 中原来属于 \\(M\\) 边从 \\(M\\) 中删除，把 \\(P\\) 中原来不属于 \\(M\\) 边加入到 \\(M\\) 中，变化后得到的新的匹配 \\(M^\\prime\\) 恰好比原匹配多一条边.\n而匈牙利算法就是不断寻找增广路 \\(P\\) ，通过取反操作得到更大的匹配 \\(M^\\prime\\) 来代替 \\(M\\).\n代码如模板所示.\n割点 #\r是无向连通图中一个顶点 \\(v\\) , 如果删除它以及它关联的边后，得到的新图至少包含两个连通分量.\n这里同样使用Tarjan算法.\n思路和求SCC的Tarjan算法类似，这里直接给出结论：\n一个顶点 \\(u\\) 是割点，当且仅当满足条件 \\(1\\) 或 \\(2\\).\n\\(u\\) 为树根，且 \\(u\\) 有两棵及以上的子树（这很好理解吧）. \\(u\\) 不为树根，且满足存在一条 \\((u,v)\\) 为树枝边使得 dfn[u] \u0026lt;= low[v] ，即 \\(u\\) 有一个孩子无法到达 \\(u\\) 以上的点. 代码如模板所示.\n桥 #\r是无向连通图中的一条边，如果删除它，得到的新图包含两个连通分量.\n求桥和求割点差不多，可以直接从代码看出差别，而且判断条件的理解也和求割点差不多，此处不过多赘述.\n双连通图 #\r不含割点的无向连通图.\n双连通分量 #\r无向连通图的最大双连通子图.\n点双连通分量 #\r通过找割点获得的双连通分量（层层递进.jpg\n边双连通分量 #\r通过找桥获得的双连通分量.\n后记 #\r本来这里有个模板合集的，但是因为太占空间就删掉了.\n以上基本算法在洛谷几乎都有原题.\n","date":"2023-07-09","externalUrl":null,"permalink":"/posts/bipgraph-and-connectivity/","section":"Posts","summary":"","title":"二分图与图的连通性","type":"posts"},{"content":"","date":"2023-07-09","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E8%AE%BA/","section":"Tags","summary":"","title":"图论","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]